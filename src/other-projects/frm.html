<!doctype html>
<html lang="en">
  <head>
    {{> head}}
  </head>

  <body class="body">
    <div class="website">
      {{> header}}

      <!-- content -->
      <main class="content">
        <div class="container">
          <div class="row">
            <div class="col">
              <article class="article">
                <h1>PHP фреймворк Zippy</h1>

                <ul class="page-nav">
                  <li><a href="#id1">Что такое Zippy?</a></li>
                  <li><a href="#id2">Главные особенности</a></li>
                  <li><a href="#id3">Архитектура</a></li>
                  <li><a href="#id4">Общие сведения</a></li>
                  <li><a href="#id5">Жизненный цикл страницы</a></li>
                  <li><a href="#id6">Основные компоненты</a></li>
                  <li><a href="#id7">WebApplication</a></li>
                  <li><a href="#id8">WebPage</a></li>
                  <li><a href="#id9">HtmlComponent</a></li>
                  <li><a href="#id10">HtmlContainer</a></li>
                  <li><a href="#id11">Label</a></li>
                  <li><a href="#id12">Panel</a></li>
                  <li><a href="#id13">Ссылки</a></li>
                  <li><a href="#id14">Компоненты формы</a></li>
                  <li><a href="#id15">Интерфейсы</a></li>
                  <li><a href="#id16">События</a></li>
                  <li><a href="#id17">Биндинг (привязка данных)</a></li>
                  <li><a href="#id18">Табличный вывод</a></li>
                  <li><a href="#id19">DataView</a></li>
                  <li><a href="#id20">DataTable</a></li>
                  <li><a href="#id21">Источники данных</a></li>
                  <li><a href="#id22">Дополнительные возможности</a></li>
                  <li><a href="#id23">Наследование страниц</a></li>
                  <li><a href="#id24">Фрагменты страниц (виджеты)</a></li>
                  <li><a href="#id25">Пользовательские компоненты</a></li>
                  <li><a href="#id26">Ajax</a></li>
                  <li><a href="#id27">Вызов метода страницы</a></li>
                  <li><a href="#id28">Сменяемые темы</a></li>
                  <li><a href="#id29">ЧПУ(SEF) и роутинг</a></li>
                  <li><a href="#id30">Кеширование</a></li>
                  <li><a href="#id31">Вспомогательный шаблонизатор</a></li>
                  <li><a href="#id32">Создание страниц в стиле SPA и Web API</a></li>
                  <li><a href="#id33">Советы и решения типовых задач</a></li>
                  <li><a href="#id34">Библиотека компонентов</a></li>
                  <li><a href="#id35">Диаграмма Ганта</a></li>
                  <li><a href="#id36">Капча</a></li>
                  <li><a href="#id37">Компоненты для работы с БД</a></li>
                  <li><a href="#id38">Twitter Bootstrap компоненты</a></li>
                </ul>

                <h2 id="id1">Что такое Zippy?</h2>

                <p>
                  <strong>Zippy</strong> – компонентный событийно- ориентированный фреймворк на
                  <a href="http://www.php.net" target="_blank">PHP</a>, предназначенный для быстрой
                  разработки сайтов. <strong>Zippy</strong> легок для изучения, обеспечивает полное
                  отделение дизайна от логики, а также отделение бизнес-логики от функций
                  обеспечения жизненного цикла и состояния элементов страницы.
                </p>

                <h2 id="id2">Главные особенности</h2>

                <ul>
                  <li>Небольшой размер.</li>
                  <li>Полное отделение дизайна от бизнес-логики.</li>
                  <li>Использование пространства имен для разделения классов и модулей.</li>
                  <li>Компонентная, легко расширяемая структура.</li>
                  <li>
                    Интуитивно понятная архитектура фреймворка и компонентов (особенно для
                    разработчиков, имеющих опыт с RAD средами типа Delphi, ASP.NET).
                  </li>
                  <li>
                    Автоматическое сохранение состояния страницы при перезагрузке (включая деревья).
                  </li>
                  <li>Прозрачная, не требующая дополнительного кодирования, поддержка Ajax.</li>
                  <li>Русская документация.</li>
                  <li>Библиотека компонентов <a class="link" href="#id34">ZCL</a>.</li>
                </ul>

                <p>
                  Главная идея – предоставить разработчику необходимый набор компонентов, который
                  позволит сосредоточиться на разработке бизнес-логики сайта.
                </p>

                <p>
                  Разработчику нет необходимости работать с запросами, роутерами, многочисленными
                  API - он работает только с событиями и свойствами серверных компонентов. Обмен
                  данными с браузером, рендеринг шаблона страницы, обработка запросов и т.д.
                  обеспечивается компонентами, соответствующими клиентским элементам страницы. То
                  есть если вы кликнули на странице по ссылке или кнопке, все что вам нужно - это
                  назначить на серверной стороне обработчик данного события для данного компонента
                  (компонент - это просто PHP класс) и написать в нем код бизнес-логики.
                </p>

                <p>
                  Обмен данными с компонентами производится через свойства этих компонентов - если,
                  например, вам нужно вывести выпадающий список, вы просто передаете компоненту
                  ассоциативный массив
                </p>

                <p>
                  Компонентная структура <strong>Zippy</strong> позволяет легко разделять работу
                  между разработчиками, расширять и создавать новые компоненты и модули. Наиболее
                  эффективное применение фреймворка – интерактивные сайты, предполагающие
                  взаимодействие с пользователями аналогично десктопным приложениям (так называемый
                  rich-интерфейс).
                </p>

                <p>
                  Основные архитектурные решения по разделению логики и представления заимствованы с
                  фреймворка Wicket (в некотором смысле можно рассматривать как портинг на PHP), а
                  также (прямо или косвенно) ряд идей с таких решений как: JSF, ASP.NET, Delphi for
                  PHP и подобных компонентно-ориентированных систем.
                </p>

                <h2>Установка</h2>

                <p>Установка фреймворка производится с помощью Composer.</p>

                <pre><code class="bash">
composer require leon-mbs/zippy

</code></pre>

                <p>В заголовке страницы указать</p>

                <pre><code class="html">
&lt;link rel="stylesheet" href="/vendor/leon-mbs/zippy/assets/css/bootstrap.css"&gt;
&lt;link rel="stylesheet" href="/vendor/leon-mbs/zippy/assets/css/zippy-bundle.min.css"&gt;
&lt;script src="/vendor/leon-mbs/zippy/assets/js/jquery.js" type="text/javascript"&gt;
&lt;script src="/vendor/leon-mbs/zippy/assets/js/bootstrap.bundle.js" type="text/javascript"&gt;
&lt;script src="/vendor/leon-mbs/zippy/assets/js/zippy-bundle.min.js" type="text/javascript"&gt;

</code></pre>

                <p>
                  Эти файлы включают необходимые фронт-энд библиотеки - JQuery, Twitter Bootstrap,
                  Awesome font и все необходимые плагины и компоненты.
                </p>

                <p>
                  Кроме того, можно
                  <a href="http://zippy.com.ua/download/frm-full.zip">скачать</a> фреймворк в сборе
                  со всеми необходимыми библиотеками в виде архива.
                </p>

                <p>
                  Репозиторий фреймворка на GitHub:
                  <a href="https://github.com/leon-mbs/zippy">Ссылка</a>
                </p>

                <p><a href="/api/index.html">Документация</a> по классам фреймворка</p>

                <h2 id="id4">Как начать</h2>

                <p>
                  Вместе с фреймворком в папке demo идет демо приложение с примерами. Это приложение
                  можно использовать как стартовое (заготовку). Нужно только заменить страницы с
                  примерами на свои. Перед началом работы разумеется необходимо выполнить Сomposer.
                </p>

                <p>
                  Можно также
                  <a href="http://zippy.com.ua/download/frm-demo.zip">скачать</a> демо-приложение в
                  сборе с фреймворком. Также можно смотреть исходники проектов, где можно найти
                  примеры организации работы с БД, подключение авторизации и пр.
                </p>

                <h2 id="id3">Архитектура</h2>

                <h3>Общие сведения</h3>

                <p>
                  Основным элементом сайта, построенного с использованием Zippy, является страница.
                  Страница состоит из PHP класса - наследника от класса
                  <a href="/api/Zippy.Html.WebPage.html" target="_blank"><code>WebPage</code></a>
                  (бэкенд) и HTML файла (фронтэнд). Для каждого элемента (HTML тэга) страницы,
                  связанного с бизнес-логикой, создается экземпляр соответствующего класса
                  (Zippy-компонент) в PHP коде.
                </p>

                <pre><code class="html">
&lt;body&gt;
  &lt;span zippy="msg"&gt;&lt;/span&gt;
  &lt;a zippy="onmsg"&gt;Клик&lt;/a&gt;
&lt;/body&gt;

</code></pre>

                <pre><code class="php">
use \Zippy\Html\Label;
use \Zippy\Html\Link\ClickLink;

class Example1 extends \Zippy\Html\WebPage
{
  //В конструкторе создаем экземпляры компонентов
  public function __construct($params=null) {
    $this->add(new Label('msg'));
    $this->add(new ClickLink('onmsg', $this, 'OnClick'));
  }

  //Обработчик клика по ссылке
  public function OnClick($sender) {
    //Присваиваем текст для вывода в тэге span
    $this->msg->setText("OK");
  }
}

</code></pre>

                <p>
                  Компонент обеспечивает рендеринг в HTML, сохранение состояния (в том числе для
                  элементов ввода), а также вызов обработчиков событий, возникающих при навигации
                  пользователя по странице. Связь между компонентом и HTML представлением
                  обеспечивается с помощью атрибута <code>"zippy"</code> в соответствующих HTML
                  тэгах. При создании экземпляра компонента в его конструктор передается значение
                  атрибута <code>"zippy"</code>, которое присваивается полю <code>id</code>,
                  определенному в классе <code>HtmlComponent</code>, от которого наследуются все
                  компоненты.
                </p>

                <p>
                  Таким образом HTML код не включает в себя никаких скриплетов и прочих чужеродных
                  вставок. При рендеринге компонент, манипулируя тегом, изменяет его значение и/или
                  значение его атрибутов, отображая таким образом свои данные в выходном HTML
                  потоке. Важное условие - иерархия компонентов страницы строго соответствует
                  вложенности соответствующих (с атрибутом <code>"zippy"</code>) HTML тэгов. Если,
                  например, ссылка или другой элемент находится в форме и для формы как и для
                  элемента необходимо создать соответствующий серверный компонент, то компонент
                  ссылки должен быть добавлен к форме вызовом метода <code>Add</code> предварительно
                  созданного объекта формы.
                </p>

                <pre><code class="html">
&lt;body&gt;
  &lt;form zippy="form1"&gt;
  &lt;input type="text" zippy="message" &gt;
  &lt;/form&gt;
&lt;/body&gt;

</code></pre>

                <pre><code class="php">        
public function __construct($params=null) {
  $this->add(new Form('form1'));
  $this->form1->add(new TextInput('message'));
}

</code></pre>

                <p>
                  Кроме компонентов сохранность состояния будет обеспечена любым членам страницы до
                  тех пор, пока не будет выполнена переадресация на другую страницу. Создание
                  экземпляра страницы производится только при первом обращении. Это аналогично
                  формам в десктопных приложениях. Мы создаем экземпляр класса формы и, пока форма
                  не будет закрыта, все данные формы сохраняются.
                </p>

                <pre><code class="php">
use \Zippy\Html\Label;
use \Zippy\Html\Link\ClickLink;

class Example1 extends \Zippy\Html\WebPage
{
  public $counter = 0;  

  //Обработчик клика по ссылке
  public function OnClick($sender) {
        
    //Присваиваем текст для вывода в тэге span     
    $this->counter++;
    $this->msg->setText("Счетчик " . $this->counter);
  }
}

</code></pre>

                <p>
                  Таким образом может быть сохранена между обновлениями страницы любая сложная
                  структура. Естественно, если нужно очистить данные в компоненте, нужно делать это
                  явно аналогично десктопным приложениям.
                </p>

                <pre><code class="php">
$this->msg->setText("");

</code></pre>

                <p>
                  Связь между классом страницы и соответствующим HTML файлом шаблона задается
                  разработчиком сайта, что позволяет избежать жесткой структуры каталогов, а также
                  легко реализовать сменяемый дизайн и/или локализацию. Жизненный цикл страницы и
                  навигация между страницами обеспечивается классом <code>WebApplication</code> в
                  зависимости от анализа запросов браузера к серверу.
                </p>

                <h3 id="id5">Жизненный цикл страницы</h3>

                <p>
                  При первом открытии страницы приложение создает экземпляр класса страницы. В
                  конструкторе страницы создаются экземпляры всех компонентов страницы, выполняется
                  биндинг и назначение обработчиков событий. Затем экземпляр класса страницы
                  сериализуется со всем содержимым и записывается в сессионное
                </p>

                <p>
                  Затем экземпляр класса страницы сериализуется со всем содержимым и записывается в
                  сессионное хранилище. После этого приложение загружает HTML шаблон с места на
                  диске, указанного разработчиком в функции <code>getTemplate</code>, парсит его и
                  вызывает метод рендеринга класса страницы. Класс страницы рендерит все дочерние
                  компоненты. Компонент изменяет соответствующий ему (связанный через атрибут
                  <code>zippy</code>) HTML тэг, корректируя его содержание и/или атрибуты. После
                  рендеринга страницы приложение отправляет измененный HTML код браузеру.
                </p>

                <p>
                  При запросе со страницы (например, клик по ссылке) приложение десериализует
                  экземпляр класса страницы из сессии и находит компонент - инициатор запроса
                  (ссылка, кнопка и т.д.). Компонент активизирует связанную с ней пользовательскую
                  функцию – обработчик события, которым обычно является метод класса страницы,
                  поскольку это позволяет иметь доступ ко всем компонентам страницы и таким образом
                  реализовать всю бизнес-логику, связанную с поведением страницы, обменом данных и
                  т.д.
                </p>

                <p>
                  Затем экземпляр страницы вместе с экземплярами всех компонентов (хранящих текущее
                  состояние данных) сохраняется в сессионном хранилище, выполняется рендеринг и
                  отправка ответа в браузер. Сессионное хранилище сохраняет историю изменения
                  страниц, что позволяет отдавать страницу с соответствующим "историческим"
                  состоянием при навигации браузера кнопками "вперед"/"назад".
                </p>

                <p>image</p>

                <h2 id="id6">Основные компоненты</h2>

                <h3 id="id7">WebApplication</h3>

                <p>
                  Класс приложения. Выполняет разбор HTTP запроса, управляет жизненным циклом
                  страницы и формирует ответ для клиента. Для использования создать экземпляр класса
                  наследнинка от
                  <a href="/api/Zippy.WebApplication.html"><code>WebApplication</code></a> и
                  переопределить минимум одну функцию загрузки шаблонов страниц
                  <code>getTemplate</code>. Входным параметром является имя класса страницы,
                  выходным - содержание шаблона. Пример реализации можно посмотреть в демо
                  приложеиии.
                </p>

                <p>
                  Управляя загрузкой шаблона можно легко реализовать сменяемые темы сайта. В сложных
                  проектах функцию обработки (или несколько функций, если модульное приложение)
                  можно установить методом <code>setTemplate</code> и может задаватся строковым
                  именем или лямбдой. В этом случае можно не создавать свой экзеспляр приложения, а
                  использовать непосредственно
                  <a href="/api/Zippy.WebApplication.html"><code>WebApplication</code></a
                  >. При создании экземпляра
                  <a href="/api/Zippy.WebApplication.html"><code>WebApplication</code></a> или
                  собственного класса-наследника в конструктор необходимо передать имя класса
                  начальной страницы сайта. Пример кода из index.php:
                </p>

                <pre><code class="php">
class Application extends \Zippy\WebApplication
{

  public function getTemplate($name)
  {
    //загрузка шаблонов для страниц
    $name = str_replace("Pages\\", "", ltrim($name, '\\'));

    $path = __DIR__ . '/' . "templates/" .  strtolower($name) . ".html";

    $template = file_get_contents($path);

    if ($template==false) {
      new \Exception('Неверный путь к шаблону страницы: ' . $path);
    }

    return $template;
  }

  //если  требуется  роутинг
  public function Route($uri){
    if($uri == '') $uri = 'page1';
      
    $uria = explode("/", $uri);
      
    if($pages[$uria[0]] == 'page1'){
      $this->LoadPage("\\Pages\\Page1");
    }
    else if ($pages[$uria[0]] == 'page2'){    
      $this->LoadPage("\\Pages\\Page2", $uria[1]); //страница с параметром
    }
    else {
      $this->getResponse()->to404Page() ;   
    }
  }
}

// создаем экземпляр приложения с параметром класса главной страницы сайта
$app = new Application('Pages\Main');

$app->Run();

</code></pre>

                <h3 id="id8">WebPage</h3>

                <p>
                  Класс страницы. Для создания класса необходимо расширить абстрактный класс
                  <a href="/api/Zippy.Html.WebPage.html"><code>WebPage</code></a
                  >. В конструкторе создаются все компоненты страницы. Иерархия компонентов должна
                  строго соответствовать вложенности тэгов с атрибутом <code>zippy</code> в шаблоне.
                  Как правило, в классе страницы создаются функции обработчиков событий, а также
                  реализуется логика работы страницы. Экземпляры компонентов страницы создаются один
                  раз при первом обращении к странице. Отслеживать жизненный цикл страницы можно
                  переопределив методы <code>beforeRequestHandle()</code>,
                  <code>afterRequestHandle()</code> и пр.
                </p>

                <p>
                  Приинцип работы класса страницы напомнинает класс бекенда в ASP WebForms или
                  десктопных Delphi/WinForms - экземпляр класса страницы (формы) содержит остальные
                  элементы как контейнер, управляет их жизненным циклом. Обработчики событий
                  элементов являются методами класса страницы.
                </p>

                <h3 id="id9">HtmlComponent</h3>

                <p>
                  Базовый класс для всех компонентов. Каждый компонент имеет уникальный в пределах
                  страницы номер элемента (поле <code>id</code>) , соответствующий аттрибуту
                  <code>zippy</code> из соответствующего тэга HTML шаблона. Каждый компонент,
                  расширяющий базовый класс, должен реализовать метод <code>RenderImpl()</code>,
                  который отвечает за рендеринг (прорисовку) компонента на странице путем изменения
                  HTML тэга, связанного с данным компонентом. Свойство
                  <code>attributes</code> позволяет управлять атрибутами HTML тэга. Содержимое тэга
                  задается классами-потомками
                  <a href="/api/Zippy.Html.HtmlComponent.html"><code>HtmlComponent</code></a> в
                  зависимости от его типа.
                </p>

                <h3 id="id10">HtmlContainer</h3>

                <p>
                  Базовый класс контейнера для компонентов. Контейнерами являются: класс страницы,
                  класс HTML формы, панели (обычно тэг <code>DIV</code>) и прочие компоненты которые
                  могут содержать в себе другие объекты типа
                  <a href="/api/Zippy.Html.HtmlComponent.html"><code>HtmlComponent</code></a> (то
                  есть HTML тэги, которые могут содержать вложенные тэги). Сам
                  <a href="/api/Zippy.Html.HtmlComponent.html"><code>HtmlComponent</code></a> также
                  является наследником от HtmlComponent . В классе перегружены методы
                  <code>__set()</code> и <code>__get()</code>, поэтому к вложенным компонентам можно
                  обращаться, используя динамическое свойство, совпадающее с <code>ID</code>
                  компонента. Например:
                </p>

                <pre><code class="html">
&lt;form zippy="form1"&gt;
  &lt;input  type="text" zippy="username"&gt;
&lt;/form&gt;

</code></pre>

                <pre><code class="php">
$form = new Form();
$form = add(new TextInput('username'));
...
$form->username->getText();

</code></pre>

                <h4>Диаграмма иерархии основных компонентов</h4>

                <p>image</p>

                <h5 id="id11">Label</h5>

                <p>
                  <a href="/api/Zippy.Html.Label.html"><code>Label</code></a> Служит для вывода
                  текстовых данных на странице. Как правило отображается с помощью тэга
                  <code>SPAN</code>, но можно использовать <code>TD</code>, <code>DIV</code> и
                  прочие, которые могут иметь текстовое содержимое внутри тега.
                </p>

                <h5 id="id12">Panel</h5>

                <p>
                  <a href="/api/Zippy.Html.Panel.html"><code>Panel</code></a> используется как
                  контейнер, когда надо временно скрыть группу элементов. Например, при
                  редактировании строки таблицы скрыть таблицу и показать форму редактирования.
                  Поскольку работа происходит в пределах той же страницы, сохраняются все
                  сортировки, фильтрация и пагинация таблицы. Как правило, компонент отображается с
                  помощью тэга <code>div</code> или другого блочного элемента.
                </p>

                <h5 id="id13">Ссылки</h5>

                <p>
                  Фреймворк содержит несколько разновидностей компонентов для HTML ссылок. Все они
                  привязываются к тэгу &lt;a&gt; шаблона.
                </p>

                <p>Наиболее используемые:</p>

                <p>
                  <a href="/api/Zippy.Html.Link.ClickLink.html"><code>ClickLink</code></a> - служит
                  для вызова обработчика события в классе cтраницы без возможности сделать закладку
                  в браузере (поскольку это не имеет смысла - ссылка не ведет на какой-либо ресурс,
                  а просто вызывает обработчик).
                </p>

                <pre><code class="php">
public function __construct($params=null) {
  $this->add(new ClickLink('onmsg'))->onClick($this, 'OnClick');
}

// Обработчик   
public function OnClick($sender) {

}
                
</code></pre>

                <p>
                  <a href="/api/Zippy.Html.Link.ClickLink.html"><code>BookmarkableLink</code></a> -
                  используется для внешнего перехода или ЧПУ с возможностью создать закладку. Для
                  указания адреса страницы указывается имя класса страницы с прямыми слешами
                </p>
                <p>/?p=Pages/Page1</p>

                <p>Могут быть указаны один или несколько (через прямой слэш) параметров</p>

                <p>/?p=Pages/Page1&arg=1</p>

                <p>
                  <a href="/api/Zippy.Html.Link.RedirectLink.html"><code>RedirectLink</code></a> -
                  используется для редиректа на другую страницу. Имя класса страницы задается как
                  параметр в конструкторе.
                </p>

                <p>
                  <a href="/api/Zippy.Html.Link.SubmitLink.html"><code>SubmitLink</code></a> -
                  отправляет форму на сервер, c возможностью вызвать обработчик события по отправке
                  формы.
                </p>

                <h5 id="id14">Компоненты формы ввода</h5>

                <p>
                  Компоненты соответствуют тегам элементов ввода HTML формы. Для принятия данных по
                  отправке формы компоненты реализуют метод <code>getRequestData()</code>, в котором
                  считывают «свои» данные с <code>$_POST</code> или <code>$_GET</code> переменных.
                  При рендеринге как и другие визуальные компоненты форматируют тэги в соответствии
                  со своими значениями.
                </p>

                <p>
                  Если значения не были изменены, отображаются данные, что были при вводе формы.
                  Таким образом автоматически сохраняется состояние всех элементов формы - полей
                  ввода, переключателей и т.д при перезагрузке страницы.
                </p>

                <p>Для реакции на отправку формы, форме назначается обработчик.</p>

                <pre><code class="php">
public function __construct($params=null) {
  $this->add(new Form('form1'))->onSubmit($this, 'OnForm1');
}

// Обработчик   
public function OnForm1($sender) {
                         
}

</code></pre>

                <p>
                  Вместо формы обработчик может быть назначен одному или нескольким компонентам типа
                  <a href="/api/Zippy.Html.Form.SubmitButton.html"><code>SubmitLink</code></a> или
                  <a href="/api/Zippy.Html.Form.SubmitButton.html"><code>SubmitButton</code></a> ,
                  которые могут отправлять форму. Компонент должен быть внутри формы.
                </p>

                <pre><code class="php">
public function __construct($params=null) {
  $this->add(new Form('form1'))->onSubmit($this, 'OnForm1');
  $this->form1->add(new SubmitLink('sl1'))->onClick($this, 'OnForm1');
}

//Обработчик   
public function OnForm1($sender) {
                           
}

</code></pre>

                <h5 id="id15">Интерфейсы</h5>

                <p>
                  Для взаимодействия между собой компонентов, существует набор интерфейсов, которые
                  должен реализовать тот или иной компонент. Наиболее используемые:
                </p>

                <ul>
                  <li>
                    <a href="/api/Zippy.Interfaces.Requestable.html"><code>Requestable</code></a> –
                    компонент способен обрабатывать HTTP запрос.
                  </li>
                  <li>
                    <a href="/api/Zippy.Interfaces.ClickListener.html"
                      ><code>ClickListener</code></a
                    >
                    – компонент может вызывать серверный обработчик события при клике мышкой.
                  </li>
                  <li>
                    <a href="/api/Zippy.Interfaces.EventReceiver.html"
                      ><code>EventReceiver</code></a
                    >
                    – может иметь методы - обработчики события
                  </li>
                  <li>
                    <a href="/api/Zippy.Interfaces.SubmitDataRequest.html"
                      ><code>SubmitDataRequest</code></a
                    >
                    – компонент принимает данные с формы.
                  </li>
                </ul>

                <h5 id="id16">События</h5>

                <p>
                  Большинство пользовательских методов страницы (в которых реализуется бизнес-логика
                  страницы) как правило являются обработчиками событий. Например: клик по ссылке,
                  отправка формы, навигация по странице и т.д.
                </p>

                <p>
                  Для назначения обработчика компоненту-инициатору указывается объект-получатель
                  (обычно <code>$this</code> - объект класса страницы) и имя метода-обработчика в
                  текстовом виде. Метод-обработчик содержит параметр <code>$sender</code> – ссылку
                  на объект-источник (одно и тоже событие может быть назначено нескольким
                  компонентам) и, при необходимости, дополнительные параметры.
                </p>

                <p>
                  В адресной строке фреймворк формирует номер страницы и иерархию компонентов, в
                  которой находится источник. При обработке запроса бекенд компоненты, являющиеся
                  контейнерами, будут передавать вызов компоненту, <code>ID</code> которого
                  следующее в иерархии, вплоть до последнего – инициатора события (то есть по
                  фронтенду которого например кликнули мышкой).
                </p>

                <p>
                  Механизм событий избавляет разработчика от забот по функционированию страницы,
                  разборе запроса и формированию ответа клиенту. Разработчик работает с методами
                  событий аналогично приложениям типа Delphi или WinForms.
                </p>

                <h5 id="id17">Биндинг (привязка данных)</h5>

                <p>
                  Позволяет связать переменную или свойство класса с данными компонента для того,
                  чтобы работать не с компонентами напрямую, а с переменными или полями
                  бизнес-объектов.
                </p>

                <p>
                  Например, при биндинге компонента <code>Label</code> с полем страницы
                  <code>$msg</code> в функциях бизнес-логики достаточно присвоить значение полю и
                  текст будет выведен на страницу компонентом <code>Label</code>. Если, например,
                  какая-либо переменная привязана к компоненту <code>TextInput</code> при вводе
                  данных с поля формы, значение поля автоматически присвоится переменной. Биндинг
                  задается ссылкой и именем привязываемого свойства.
                </p>

                <pre><code class="php">
use  \Zippy\PropertyBinding as  Bind;

class Example2 extends \Zippy\Html\WebPage {

  public $msg, $text;

  public function __construct($params=null) {
    $this->add(new Label('outputtext', new Bind($this, 'msg')));
    $form = $this->add(new Form('form1'));
    $form->onSubmit($this, 'OnSubmit');
    $form->add(new TextInput('inputtext', new Bind($this, 'text')));
  }

  public function OnSubmit($sender) {
    $this->msg = $this->text;
  }
} 

</code></pre>

                <h2 id="id18">Вывод списочных данных</h2>

                <h3 id="id19">DataView</h3>

                <p>
                  Основное назначение компонента
                  <a href="/api/Zippy.Html.DataList.DataView.html"><code>DataView</code></a> - вывод
                  табличных данных.
                </p>

                <p>Пример на основе демо приложения.</p>

                <pre><code class="html">
&lt;table &gt;
  &lt;tr&gt;&lt;th&gt;ФИО&lt;/th&gt;&lt;th&gt;Возраст&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt;
  &lt;tr zippy="list"&gt;&lt;td&gt;&lt;span zippy="fio"&gt;&lt;/span&gt;&lt;/td&gt;
  &lt;td&gt;&lt;span zippy="age"&gt;&lt;/span&gt;&lt;/td&gt;
  &lt;td&gt;&lt;a zippy="edit"&gt;Редактировать&gt;&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

</code></pre>

                <pre><code class="php">
public function __construct()
{
   $this->add(new DataView('list', new DataSource(), $this, 'listOnRow'))->Reload();
} 

public function listOnRow($row){
  //получаем объект данных, связанный со строкой 
  $item = $row->getDataItem();

  //создаем компоненты в строке
  $row->add(new Label('fio', $item->fio));
  $row->add(new Label('age', $item->age));
  $row->add(new ClickLink('edit'))->onClick($this, 'editOnClick');
}    

//обработчик редактирования
public function editOnClick($sender){
  //получаем объект данных, связанный со строкой 
  $item = $sender->getOwner()->getDataItem();

  //заполняем форму редактирования и т.д.
}

</code></pre>

                <p>
                  Для инициализации вывода необходим источник данных, возвращающий массив обьектов
                  классов, реализующих интерфейс
                  <a href="/api/Zippy.Interfaces.DataItem.html"><code>DataItem</code></a> или
                  расширяющий класс <a href="/api/ZCL.DB.Entity.html"><code>Entity</code></a> и
                  обработчик, в котором будут создаваться компоненты вывода.
                </p>

                <p>
                  Строка данных - обычный контейнер, базирующийся на теге &lt;tr&gt;. Добавлять
                  можно любые компоненты (кроме вложенных DataView). DataView сам размножит
                  компоненты данных для каждой строки. При необходимости можно добавить пагинатор
                  <a href="/api/Zippy.Html.DataList.Paginator.html"><code>Paginator</code></a> или
                  <a href="/api/Zippy.Html.DataList.Pager.html"><code>Pager</code></a
                  >.
                </p>

                <pre><code class="html">
&lt;div zippy="pag&gt;&lt;/div&gt;

</code></pre>

                <pre><code class="php">
$this->add(new DataView('list', new DataSource(), $this, 'listOnRow'));

//добавляем  пагинатор для вывода
$this->add(new Paginator("pag", $this->list));

//устанавливаем количество строк на странице
$this->list->setPageSize(25);
 
$this->list->Reload();

</code></pre>

                <p>
                  DataView может использовать для вывода и другие блочные элементы, например, если
                  надо вывести список товаров или галерею рисунков. Для примера выше (бекенд тот же)
                </p>

                <pre><code class="html">
&lt;div class="row"&gt;
  &lt;div class="col-md-4" zippy="list"&gt;
    &lt;span zippy="fio"&gt;&lt;/span&gt;
    &lt;span zippy="age"&gt;&lt;/span&gt;
  &lt;/div&gt; 
&lt;/div&gt; 

</code></pre>

                <h3 id="id20">DataTable</h3>

                <p>
                  Компонент
                  <a href="/api/Zippy.Html.DataList.DataTable.html"><code>DataTable</code></a>
                  предназначен для работы с тегом &lt;table&gt;. Компонент сам создает заголовки и
                  пагинацию (если указано), но выводит данные только в виде строк. Компонент чаще
                  всего используется для вывода различного рода репортов и прочих данных, не
                  требующих бэкенд компонентов.
                </p>

                <p>
                  При создании компонента нужно создать экземпляры столбцов с указанием необходимых
                  параметров. Для кастомизации вывода предусмотрено н обработчик
                  <code>setCellDrawEvent</code> рендеринга ячейки, которому передается имя столбца и
                  идентификатор записи. Также можно установить обработчик
                  <code>setCellClickEvent</code> клика по ячейке
                </p>

                <pre><code class="html">
&lt;table zippy="report&gt;&lt;/div&gt;

</code></pre>

                <pre><code class="php">
//выводим таблицу с заголовком и пагинатором
$this->add(new \Zippy\Html\DataList\DataTable("report", new DataSource(), true, true));
                       
//создаем столбцы с указанием сортировки
$this->report->addColumn(new Column('fio', 'ФИО', true ));
$this->report->addColumn(new Column('age', 'Возраст', true ));

</code></pre>

                <h3 id="id21">Источники данных</h3>

                <p>
                  Источник данных - промежуточный компонент, унифицирующий передачу данных от разных
                  источников компонентам
                  <a href="/api/Zippy.Html.DataList.DataView.html"><code>DataView</code></a> и
                  DataTable . Источник данных должен реализовать интерфейс
                  <a href="/api/Zippy.Interfaces.DataSource.html"><code>DataSource</code></a> .
                  Методы интервейса предписывают реализацию источником условий выборки, сортировки и
                  пагинации.
                </p>

                <p>Существует несколько видов источников.</p>

                <p>
                  <a href="/api/Zippy.Html.DataList.ArrayDataSource.html"
                    ><code>ArrayDataSource</code></a
                  >
                </p>

                <p>
                  ArrayDataSource применяется в случае использования массивов как набора данных.
                  Если массив может изменятся в процессе работы, следует передавать массив не
                  напрямую, а использовать биндинг (см. демо приложение).
                </p>

                <p>
                  <a href="/api/ZCL.DB.EntityDataSource.html"><code>EntityDataSource</code></a>
                </p>

                <p>
                  EntityDataSource применяется для работы с
                  <a href="/api/ZCL.DB.Entity.html"><code>Entity</code></a
                  >. Источнику передается как параметр имя класса сущности, унаследованной от
                  Entity.
                </p>

                <h4>Пользовательский источник</h4>

                <p>
                  Для сложных выборок разработчик может создать свой класс источника данных и, если
                  нужно, связать его с компонентами страницы (например, фильтрацией).
                </p>

                <pre><code class="php">
class DocDataSource implements \Zippy\Interfaces\DataSource
{
  private function getWhere()
  {
    //возвращает условие для SQL запроса
    return $where;
  } 

  public function getItemCount()
  {
    //количество для пагинатора
    return Document::findCnt($this->getWhere());
  } 

  public function getItems($start, $count, $sortfield=null, $asc=null)
  {
    //выбирает данные 
    $docs = Document::find($this->getWhere(), "document_date desc,document_id desc", $count, $start);
    return $docs;
  }
        
  public function getItem($id)
  {
              
  }            
}
    
//используется  как  обычный источник
$this->add(new DataView('list', new DocDataSource(), $this, 'listOnRow'))->Reload();

</code></pre>

                <h2 id="id22">Дополнительные возможности</h2>

                <h3 id="id23">Наследование страниц</h3>

                <p>
                  Наследование страниц предназначено для решения проблемы "единообразия" страниц.
                  Если необходимо иметь на сайте меню, логотип и прочие неизменяемые от страницы к
                  странице части, тогда нужно разместить их в базовой странице, а изменяемый контент
                  вынести в дочерние. На уровне классов дочерняя страница просто наследуется от
                  базовой, наследуя все ее компоненты и обработчики, на уровне разметки - содержимое
                  тэга BODY дочерней страницы вкладывается внутрь базовой вместо тэга
                  &lt;childpage/&gt;.
                </p>

                <p>
                  Если в шаблоне дочерней страницы в &lt;head&gt; есть метатеги &lt;title&gt;,
                  &lt;description&gt; и &lt;keyword&gt;, при рендеринге дочерней страницы эти теги
                  будут перенесены с заменой в базовый шаблон.
                </p>

                <p>
                  Дочерние страницы имеют доступ ко всем компонентам, объявленным в родительской и
                  может ими управлять.
                </p>

                <p>Например подсвечивать текущий пункт меню.</p>

                <p>
                  Как пример - страница Base в демо приложении, от которой наследуются остальные.
                </p>

                <h4 id="id24">Фрагменты страниц (виджеты)</h4>

                <p>
                  Фрагмент страницы - это самостоятельный блок, который добавляется в страницу как
                  обычный компонент, но при этом имеет свой шаблон (загружается аналогично шаблону
                  страницы). Используется, если на некоторых страницах необходимо иметь один и тот
                  же блок данных. Например: форма поиска, блок вывода рекламы и т.д. Фрагмент может
                  содержать любые другие компоненты и обработчики событий как обычная страница. В
                  разметку страницы компонент обычно добавляется с помощью тэга DIV. Создается класс
                  фрагмента наследованием от класса
                  <a href="/api/Zippy.Html.PageFragment.html"><code>PageFragment</code></a
                  >, который, в свою очередь, наследован от
                  <a href="/api/Zippy.Html.HtmlContainer.html"><code>HtmlContainer</code></a
                  >.
                </p>

                <h4 id="id25">Пользовательские компоненты</h4>

                <p>
                  Пользовательский компонент позволяет програмно сформировать произвольное
                  содержимое для тэга (как правило DIV). Для создания пользовательского компонента
                  (по сути пользовательского тэга) нужно создать класс-наследник от
                  <a href="/api/Zippy.Html.CustomComponent.html"><code>CustomComponent</code></a> и
                  перегрузить абстрактный метод <code>getContent()</code>. Этот метод должен вернуть
                  HTML код, который будет записан в тэг в шаблоне страницы, предназначенный для
                  вывода компонента.
                </p>

                <h3 id="id26">Ajax</h3>

                <p>
                  Поскольку фреймворк автоматически обеспечивает сохранность состояния страницы,
                  использование <code>AJAX</code> в <code>Zippy</code> менее востребовано по
                  сравнению с другими решениями. Тем не менее ряд компонентов могут использовать
                  асинхронную обработку событий. Как правило использование <code>AJAX</code> не
                  требует какого-то особого кодирования и настройки. Например, для AJAX обработчика
                  <code>onClick()</code> по клику на ссылке для компонента
                  <code>ClickLink</code> нужно только указать третий параметр как true. Для отправки
                  формы через <code>AJAX</code> используется компонент <code>AjaxSubmitLink</code>.
                  Обработчики события и бизнес-логика страницы выполняются аналогично обычному
                  синхронному.
                </p>

                <p>
                  Также многие компоненты имеют возможность обновляться на странице после
                  <code>AJAX</code>
                  вызова. Поскольку обычный рендеринг всей страницы в этом случае не выполняется,
                  необходимо указать обновляемые элементы в обработчике события (метод страницы
                  <code>updateAjax()</code>). Для этих компонентов (реализующих интерфейс
                  <code>AjaxRender</code>) формируется клиентский скрипт, который обновляет их после
                  <code>AJAX</code> ответа.
                </p>

                <p>Пример:</p>

                <pre><code class="php">
$this->add(new ClickLink('time'))->onClick($this, 'OnClick', true);
$this->add(new Label('msg'));

// ...

public function OnClick($sender) {
  $this->msg->setText('Я обновлен через AJAX');
  
  //указываем обновляемые компоненты
  $this->updateAjax('msg');
}

</code></pre>

                <h3 id="id27">Вызов метода страницы</h3>

                <p>
                  В некоторых случаях необходимо вызвать метод страницы, не связанный с каким-либо
                  компонентом. Вызов выполняется асинхронно с помощью AJAX запроса.
                </p>

                <p>В общем случае вызываемый метод выглядит так:</p>

                <pre><code class="php">
public function MyMethod($p, $post) {
  return "Привет";
}

</code></pre>

                <p>
                  Где $p - массив параметров, если они были переданы в строке запроса, $post -
                  данные (raw) отправленые в случае POST запроса.
                </p>

                <p>Пример обращения с шаблона страницы:</p>

                <pre><code class="js">
callPageMethod('MyMethod', [], null, function(answerdata){
                     
})  

</code></pre>

                <p>где:</p>

                <ul>
                  <li>callPageMethod - встроеная javascript функция.</li>
                  <li>callPageMethod (method,params,postdata,callback)</li>
                  <li>method - имя метода</li>
                  <li>params - массив параметров</li>
                  <li>postdata - данные тела POST запроса (может быть FormData)</li>
                  <li>callback - функция, принимающая текстовый параметр - ответ сервера</li>
                </ul>

                <h3 id="id28">Сменяемые темы</h3>

                <p>
                  Переключение сменяемых дизайнов осуществляется путем простого переключения пути к
                  файлам в методе <code>getTemplate()</code> приложения. Например, файлы шаблонов
                  страницы можно расположить в разных папках.
                </p>

                <h3 id="id29">ЧПУ(SEF) и роутинг</h3>

                <p>
                  Роутинг осуществляется перегрузкой метода Route() приложения (см. выше пример для
                  WebApplication) . Функция принимает параметром URI и загружает страницу,
                  соответствующую вызову. Если присутствуют параметры, они идут через прямой слеш и
                  передаются конструктору страницы. Например, для /user/2 конструктор страницы будет
                  <code>public function __construct($id)</code>.
                </p>

                <h3 id="id30">Кеширование</h3>

                <p>
                  Поскольку содержимое страниц уже сериализуется и хранится в объекте сессии, а
                  объект сессии в нагруженых приложениях обычно закеширован, то кеширование страниц
                  не требует специального решения.
                </p>

                <h4 id="id31">Вспомагательный шаблонизатор</h4>

                <p>
                  Применение вспомагательного шаблонизатора (используется
                  <a href="http://mustache.github.io/">Mustache</a>) не совсем согласуется с
                  компонентной архитектурой фреймворка. Но, как показала практика, иногда
                  использование компонентов только для вывода текстов и управления видимостью
                  элементов страницы получается несколько громоздким, поскольку данные операции
                  фактически не требуют бэкенд обьектов. В этих случаях можно использовать более
                  традиционый шаблонизатор. Данные для шаблонизатора присваиваются массиву
                  <code>_tvars</code>, члену класса <code>WebPage</code>.
                </p>

                <h3 id="id32">Создание страниц в стиле SPA и Web API</h3>

                <p>
                  Страница может не содержать компонентов, а только независимые методы, вызываемые с
                  помощью javascript функции <code>callPageMethod</code> (см. выше). Это позволяет
                  делать страницы в SPA стиле, которые не перезагружаются (до смены страницы) при
                  запросе к серверу. Серверный код страницы в таком случае работает как Web Api. При
                  этом сохраняется работа PHP сессий, в частности, не требуется отдельная
                  авторизация. Как пример, страница АРМ кухни в складской системе сделаная на Vue.
                </p>

                <h2 id="id33">Советы и решения типовых задач</h2>

                <h3>Скрытие связанных элементов.</h3>

                <p>
                  Если нужно скрыть, например, лейбл вместе с элементом ввода, можно использовать
                  атрибут "data-label", например:
                </p>

                <pre><code class="html">
&lt;label data-label="paynotes" for="paynotes"&gt; Комментарий к оплате&lt;/label&gt;
&lt;input class="form-control" type="text" zippy="paynotes"&gt;

</code></pre>

                <p>
                  Если поле ввода paynotes будет скрыто функцией <code>setVisible(false)</code>,
                  лейбл скроется вместе с ним.
                </p>

                <h3>Переход по якорю.</h3>

                <p>
                  Для перехода в опредлеленное место страницы после обработки события можно
                  использовать метод goAnkor() класса страницы. Параметром является id элемента или
                  атрибут zippy (атрибуты id и name создаются в таком случае автоматически).
                </p>

                <h3>Перехват событий яваскриптом на элементах с серверным обработчиком.</h3>

                <p>
                  Когда элемент имеет серверный обработчик, обычно на событие onclick фреймворк
                  вешает соответствующий клиентский обработчик. Допустим нужно выполнить код на
                  клиенте до того как сработает серверный обработчик. Например, спросить
                  пользователя о подтверждении действия, или если есть ссылка
                  <code>&lt;a zippy="deleteitem"&gt;Удалить итем &lt;/a&gt;</code>, для перехвата
                  нужно написать функцию с предопределенным именем, начинающуюся с check_
                </p>

                <pre><code class="js">
&lt;script&gt;
  function check_deleteitem() { 
    return confirm("Удалить итем?")
  }          
&lt;/script&gt;

</code></pre>

                <h2 id="id34">Библиотека компонентов</h2>

                <p>
                  Библиотека представляет собой набор компонентов, построенных на расширении
                  стандартных компонентов фреймворка. Библиотека не входит в ядро фреймворка и
                  располагается в отдельном пространстве имен ZCL. Библиотека состоит из следующих
                  компонентов:
                </p>

                <h3 id="id35">Диаграмма Ганта</h3>

                <p>
                  Компонент представляет собой реализацию серверной части для
                  <a href="https://github.com/thegrubbsian/jquery.ganttView">jquery.ganttview</a>.
                </p>

                <h3 id="id36">Капча</h3>

                <p>
                  Компонент реализует функциональность простейшей капчи полностью инкапсулируя
                  генерацию кода, рисунка, формирование ссылки на рисунок и, если задан
                  соответствующий параметр, асинхронное обновление капчи по клику на рисунке.
                </p>

                <p>
                  Для реализации собственного алгоритма достаточно отнаследоваться от компонента и
                  переопределить метод <code>OnCode</code> для генерации кода и/или метод
                  <code>OnImage</code> для генерации изображения. Описание методов на странице
                  <a href="http://zippy.com.ua/api/ZCL.Captcha.html"><code>API</code></a
                  >. Для вывода компонента на странице используется обычный тег
                  <code>&lt;img&gt;</code>.
                </p>

                <h3 id="id37">Компоненты для работы с БД</h3>

                <p>
                  Нeсколько компонентов для работы с базами данных. Компоненты базируются на
                  библиотеке
                  <a href="http://adodb.sourceforge.net/" target="_blank" title="ADODB"
                    ><code>ADODB</code></a
                  >, что позволяет писать код, защищенный от sql-инъекций и переносимый между
                  разными типами БД. (На данный момент основные компоненты работы с БД выделены в
                  отдельный проект <a target="_blank" href="/zdb">ZDB</a>) TreeEntity -
                  класс-наследник Entity , предназначенный для работы с иерархически организованными
                  сущностями.
                </p>

                <p>
                  В дополнение к функционалу родительского класса имеет возможномть манипулировать
                  дочерними элементами (поиск по дереву, удаление, перемещение веток), строить
                  дерево для компонента <code>Tree</code> на основе набора данных из БД. Данные
                  должны быть организованы в соответствии с алгоритмом материализованного пути.
                </p>

                <p>
                  EntityDataSource - универсальный источник данных, реализующий интерфейс
                  DataSource, позволяющий связать страничные компоненты табличного и списочного
                  вывода с БД. В параметрах класса задаются имя класса-сущности (Entity) и, при
                  необходимости, условие для выборки. Это позволяет разработчику избежать создания
                  специализированного источника для простых линейных выборок.
                </p>

                <h3 id="id38">Twitter Bootstrap компоненты</h3>

                <p>Некоторые компоненты, базирующиеся на Twitter Bootstrap.</p>

                <ul>
                  <li>
                    <a target="_blank" href="http://www.jondmiles.com/bootstrap-treeview"
                      >Bootstrap TreeView</a
                    >
                  </li>
                  <li>
                    <a target="_blank" href="https://github.com/maxwells/bootstrap-tags"
                      >Bootstrap Tags</a
                    >
                  </li>
                </ul>
              </article>
            </div>
          </div>
        </div>
      </main>
      <!-- end content -->

      {{> footer}}
    </div>

    {{> scripts}}
  </body>
</html>
