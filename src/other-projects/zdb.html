<!doctype html>
<html lang="en">
  <head>
    {{> head}}
  </head>

  <body class="body">
    <div class="website">
      {{> header}}

      <!-- content -->
      <main class="content">
        <div class="container">
          <div class="row">
            <div class="col">
              <article class="article">
                <h1>ZDB</h1>

                <h2>Библиотека для доступа к БД</h2>

                <p>
                  Библиотека представляет собой Active Record, построеный на функциональности
                  библиотекаи ADODB. Библиотека позволяет работать с бизнес-сущностями, не используя
                  маппинг или иной способ явного указания связи полей бизнес-сущности с полями
                  таблицы БД.
                </p>

                <ul>
                  <li>Основной репозитарий на Гитхабе</li>
                  <li>Описание идеи в статье на Хабре</li>
                  <li>Документация по классам библиотеки ZDB\DB</li>
                </ul>

                <p>
                  Класс, реализующий коннект к БД. Синглетон-обертка для ADODB. Для инициализации
                  необходимо передать параметры соединения.
                </p>

                <p>\ZCL\DB\DB::config($host, $dbname,$dbuser,$dbpass,[$driver=mysqli]);</p>

                <p>Получение коннекта (для нативных запросов)</p>

                <p>DB::getConnect();</p>

                <p>ZDB\Entity</p>

                <p>Основной класс библиотеки, являющийся базовым для всех Entity.</p>

                <p>К примеру, есть таблица пользователей</p>

                <pre><code class="sql">
CREATE TABLE  `users` (
              `username` varchar(255) ,
              `updated` date  ,
              `user_id` int(11) NOT NULL AUTO_INCREMENT,
               PRIMARY KEY (`user_id`)
)
               </code></pre>

                <p>Создадим класс сущности Пользователь на основе класса ZDB\Entity</p>

                <pre><code class="php">
/**
* @table=users
* @keyfield=user_id
*/
class User extends Entity{
                  
  protected function init() {
    $this-&gt;user_id = 0;
    $this-&gt;updated = time();
  }
                  
  protected function afterLoad() {
    $this-&gt;updated = strtotime($this-&gt;updated);
  }    
}
</code></pre>

                <p>
                  Если у нас есть представление для выборки пользователей, например usersview, тогда
                  мы указываем в псевдоаннотациях @view=usersview. В этом случае выборка данных
                  будет идти из представления, а запись в таблцу.
                </p>

                <p>
                  Метод init() используется для инициализации полей. Метод afterLoad() вызывается
                  после загрузки содержимого из соответствующей строки таблицы БД. В данном случае
                  преобразовывает дату в timestamp для универсальности дальнейшей работы.
                </p>

                <p>
                  Оба метода необязательны. Самое важное - имена полей, к которым идет обращение при
                  работе с экземпляром сущности, должны совпадать с именами в таблице БД. Все
                  остальное будет автоматизировано библиотекой ADODB. При сохранении данных
                  библиотека сама определит типы полей Бд и сформирует SQL запрос с соответствующими
                  преобразованиями. Никакого специального маппинга полей или генерации структур не
                  нужно
                </p>

                <p>Некоторые примеры работы с Entity:</p>

                <pre><code class="php">
//загрузка пользователя.
$user = User::load($id);
                    
//записать  пользователя с  новыми  значениями.
$user-&gt;username='newname';
$user-&gt;updated = time();
$user-&gt;save();
                  
//новый пользователь
//если $user-&gt;user_id равен 0 создается новая запись  и полю $user-&gt;user_id  
//присваивается значение  из  автоинкрементного поля.
$user = new  User();
$user-&gt;username='newname';
$user-&gt;save();
                    
//удаление  пользователя
User::delete($id);
                    
//найти всех  пользователей кроме  админа
$users = User::find("username &lt;&gt; 'admin'");
                  
//найти количество  пользователей
$users = User::findCnt();
                    
//вернуть имена  пользователей в  виде  массива  ключ/значение
// например для  комбобокса
$users = User::findArray("username","","username asc");
</code></pre>

                <p>
                  Класс сущности - обычный класс и может быть расширен любыми необходимыми методами.
                  Например: проверка юзера по логину и паролю.
                </p>
              </article>
            </div>
          </div>
        </div>
      </main>
      <!-- end content -->

      {{> footer}}
    </div>

    {{> scripts}}
  </body>
</html>
